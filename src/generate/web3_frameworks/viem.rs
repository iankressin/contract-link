use crate::types::{ContractMetadata, IntermediateContracts};

use super::GenerateWeb3;
use std::{collections::HashMap, error, fs, path::PathBuf, u64};

pub struct Viem;

impl GenerateWeb3 for Viem {
    fn generate(
        app_path: &PathBuf,
        intermidiate_contracts: IntermediateContracts,
    ) -> Result<(), Box<dyn error::Error>> {
        Viem::generate_web3(app_path, &intermidiate_contracts)?;

        // TODO: this call is overrinding the ABIs generated by the previous call

        intermidiate_contracts
            .iter()
            .for_each(|(_, contracts)| {
                Viem::update_abi_files(app_path, &contracts).unwrap();
            });

        Ok(())
    }

    // create a contract address file
    // create/update abi files
    fn generate_web3(
        app_path: &PathBuf,
        intermidiate_contracts: &IntermediateContracts,
    ) -> Result<(), Box<dyn error::Error>> {
        let mut contract_addresses_hashmap: HashMap<u64, HashMap<String, String>> =
            std::collections::HashMap::new();

        intermidiate_contracts
            .iter()
            .for_each(|(chain_id, contracts)| {
                let mut chain_contracts: HashMap<String, String> = std::collections::HashMap::new();
                contracts.iter().for_each(|contract| {
                    chain_contracts.insert(contract.name.clone(), contract.address.clone());
                });

                contract_addresses_hashmap.insert(*chain_id, chain_contracts);
            });

        let mut contract_addresses_js = "export const ContractAddress = {\n".to_owned();

        for (chain_id, contracts) in &contract_addresses_hashmap {
            contract_addresses_js.push_str(&format!("  {}: {{\n", chain_id));

            for (contract_name, address) in contracts {
                contract_addresses_js
                    .push_str(&format!("    \"{}\": \"{}\",\n", contract_name, address));
            }

            contract_addresses_js.push_str("  },\n");
        }

        contract_addresses_js.push_str("} as const;\n");

        let contract_addresses_path = app_path
            .join("src")
            .join("lib")
            .join("constants")
            .join("contract-addresses.ts");
        println!("Contracts path: {}", contract_addresses_path.display());
        fs::write(contract_addresses_path, contract_addresses_js)
            .expect("Failed to write contract addresses file");

        Ok(())
    }

    fn update_abi_files(
        app_path: &PathBuf,
        intermidiate_contracts: &Vec<ContractMetadata>,
    ) -> Result<(), Box<dyn error::Error>> {
        intermidiate_contracts.iter().for_each(|contract| {
            let abi_file_path = app_path
                .join("src")
                .join("lib")
                .join("abis")
                .join(format!("{}.ts", contract.name));
            let abi_json = serde_json::to_string_pretty(&contract.abi).unwrap();

            println!("Serialized abi:{abi_json} {}", abi_file_path.display());

            let abi_ts = format!("export default {abi_json} as const;\n");
            fs::write(abi_file_path, abi_ts).expect("Failed to write abi file");
        });

        Ok(())
    }
}
